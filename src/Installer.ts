import * as path from 'path';
import * as fs from 'fs';

import * as ts from 'typescript';
import { System, URL, assign, keys } from 'requirex';

import { PackageJson, PackagesConfig } from '.';
import { promisify, writeFile } from './fs';

const autogenerated = (
	'// This file is autogenerated by mrepo.\n' +
	'// Changes will be overwritten.\n\n'
);
const emptyPromise = Promise.resolve();
const reDir = /\/$/;

const latestMeta: {
	lockedVersion?: string,
	suggestedVersion?: string
} = { suggestedVersion: 'latest' };

/** Map kebab-case module names to camelCase exported variable names. */

function camelize(name: string) {
	return(name.replace(/-./g, function(match) {
		return(match[1].toUpperCase());
	}));
}

function relative(src: string, dst: string) {
	const result = path.relative(src, dst);

	return /^\.\.?\//.test(result) ? result : './' + result;
}

export class Installer implements PackagesConfig {

	constructor(config: PackagesConfig) {
		const { basePath, scope, packages, tsconfigPaths } = config;

		this.basePath = basePath;
		this.scope = scope;
		this.packages = packages;

		this.pkgPath = path.resolve(basePath, scope || '.');

		if(tsconfigPaths) {
			let { referencesIn, referencesOut } = tsconfigPaths;

			if(referencesIn) {
				referencesIn = this.fixTsconfigPaths(referencesIn);
				this.referencesIn = referencesIn;
				this.shortRefsIn = referencesIn.replace(/\/tsconfig.json$/, '');
			}

			if(referencesOut) {
				this.referencesOut = this.fixTsconfigPaths(referencesOut);
				this.shortRefsOut = referencesOut.replace(/\/tsconfig.json$/, '');
			}
		}
	}

	fixTsconfigPaths(paths: string) {
		if(!paths) return paths;

		if(!reDir.test(paths)) {
			for(let name of keys(this.packages)) {
				try {
					if(
						fs.statSync(
							path.resolve(this.pkgPath, name, paths)
						).isDirectory()
					) {
						paths += '/';
						break;
					}
				} catch(err) { }
			}
		}

		if(reDir.test(paths)) {
			paths += 'tsconfig.json';
		} else if(!/\.json$/.test(paths)) {
			paths += '.json';
		}

		return paths;
	}

	getFullName(name: string) {
		return (this.scope || '') + (this.scope && '/') + name;
	}

	readFile(name: string): Promise<Buffer>;
	readFile(name: string, encoding: string): Promise<string>;
	readFile(name: string, encoding?: string) {
		return promisify<Buffer | string>((handler) => fs.readFile(
			path.resolve(this.basePath, name),
			encoding,
			handler
		));
	}

	writePackage(name: string, json: PackageJson) {
		return writeFile(
			path.resolve(this.pkgPath, name, 'package.json'),
			JSON.stringify(json, null, '  ').replace(/\$NAME/g, name),
		);
	}

	createTsProject() {
		const references: string[] = [];

		if(!this.shortRefsIn) return;

		for(let name of keys(this.packages)) {
			references.push(
				'{ "path": "' +
				name +
				'/' +
				this.shortRefsIn +
				'" }'
			);
		}

		const buildConfig = autogenerated + [
			'{',
			'\t"references": [',
			'\t\t' + references.join(',\n\t\t'),
			'\t],',
			'\t"files": []',
			'}'
		].join('\n') + '\n';

		writeFile(
			path.resolve(this.basePath, 'tsconfig.json'),
			buildConfig
		);
	}

	makeCopies(copyFiles?: { [targetPath: string]: string }) {
		return Promise.all(keys(copyFiles || {}).map((dst: string) =>
			this.readFile(copyFiles![dst]).then((buf: Buffer) =>
				Promise.all(keys(this.packages).map(
					(name: string) => writeFile(
						path.resolve(this.pkgPath, name, dst),
						buf
					)
				))
			)
		)).then(() => {});
	}

	applyPackageTemplate(templatePath?: string) {
		const { packages } = this;

		// TODO: Maybe read existing package configs to packageTbl?
		if(!templatePath) return emptyPromise;

		return this.readFile(templatePath, 'utf-8').then((data: string) => {
			const template = JSON.parse(data);
			this.packageContent = template;

			return Promise.all(keys(packages).map((name: string) => {
				const fullName = this.getFullName(name);
				const json: PackageJson = { name: fullName };

				assign(json, packages[name], -1);
				assign(json, template, -1);

				this.packageTbl[fullName] = { json, deps: {} };

				return this.writePackage(name, json);
			}))
		}).then(() => {});
	}

	getTsconfigTemplate(templatePath?: string) {
		if(!templatePath) return emptyPromise;

		return this.readFile(templatePath, 'utf-8').then((data: string) => {
			this.tsconfigContent = JSON.parse(data);
		});
	}

	transpile(prefix: '~' | '^' | '' = '~') {
		const { basePath, scope, packages, packageTbl } = this;

		if(!this.referencesOut) return emptyPromise;

		const parseConfigHost: ts.ParseConfigHost = {
			fileExists: ts.sys.fileExists,
			readDirectory: ts.sys.readDirectory,
			readFile: ts.sys.readFile,
			useCaseSensitiveFileNames: true
		};

		for(let name of keys(packages)) {
			const { options, fileNames } = ts.parseJsonConfigFileContent(
				this.tsconfigContent,
				parseConfigHost,
				path.dirname(path.resolve(
					basePath,
					'node_modules',
					scope || '.',
					name,
					this.referencesOut
				))
			);

			options.declaration = false;
			options.sourceMap = false;

			const host: ts.LanguageServiceHost = {
				getCompilationSettings: () => options,
				getScriptFileNames: () => fileNames,
				getScriptVersion: (key: string) => '0',
				getCurrentDirectory: ts.sys.getCurrentDirectory,
				getDefaultLibFileName: (options) => ts.getDefaultLibFilePath(options),
				getScriptSnapshot: (key: string) => !fs.existsSync(key) ? void 0 : (
					ts.ScriptSnapshot.fromString(fs.readFileSync(key, 'utf-8'))
				)
			};

			const service = ts.createLanguageService(host, ts.createDocumentRegistry());

			for(let key of fileNames) {
				for(let output of service.getEmitOutput(key).outputFiles) {
					System.record(URL.fromLocal(output.name), output.text);
				}
			}
		}

		return Promise.all(keys(packageTbl).map((fullName: string) => {
			/* System.config({
				mainFields: ['module', 'main']
			}); */

			return System.analyze(
				fullName,
				URL.fromLocal(this.basePath) + '/'
			).then((result) => {
				const pkg = packageTbl[fullName];

				for(let dep of keys(result)) {
					if(dep != fullName) {
						const meta = System.manager.packageMetaTbl[dep] || latestMeta;
						pkg.deps[dep] = meta.suggestedVersion || prefix + meta.lockedVersion;
					}
				}
			})
		})).then(() => { });
	}

	// TODO: Produce UMD bundles with and without deps!

	createRollupConfig(configPath?: string, bundlePath?: string, bundleMinPath?: string) {
		const { packageContent } = this;

		if(
			!configPath ||
			!packageContent ||
			!packageContent.module ||
			!packageContent.browser
		) return;

		const rollupConfig: string[] = [];
		configPath = path.resolve(this.basePath, configPath);

		for(let name of keys(this.packages)) {
			const fullName = this.getFullName(name);
			const pkg = this.packageTbl[fullName];
			if(!pkg) continue;

			const globals: { [name: string]: string } = {};

			for(let dep of keys(pkg.deps)) {
				globals[dep] = camelize(dep.replace(/^@[^/]+\//, ''));
			}

			const input = '"input": "' + relative(
				path.dirname(configPath),
				path.resolve(this.pkgPath, name, packageContent.module)
			) + '"';

			const output: any = {
				name: camelize(name),
				format: 'umd'
			};

			const onwarn = '"onwarn": mrepo.onwarn';

			const plugins = [
				'{ "resolveId": mrepo.resolve }'
			];

			if(bundlePath) {
				output.file = relative(
					path.dirname(configPath),
					path.resolve(this.pkgPath, name, bundlePath)
				);

				if(bundleMinPath) {
					plugins.push(
						'{ "renderChunk": function(code) { return mrepo.minify(code, ' +
						JSON.stringify(path.resolve(this.pkgPath, name, bundleMinPath)) +
						'); } }'
					);
				}

				rollupConfig.push('{\n\t\t' + [
					input,
					'"output": ' + JSON.stringify(output, null, '\t').split('\n').join('\n\t\t'),
					onwarn,
					'"plugins": [\n\t\t\t' + plugins.join(',\n\t\t\t') + '\n\t\t]'
				].join(',\n\t\t') + '\n\t}');

				plugins.pop();
			}

			output.globals = globals;
			output.file = relative(
				path.dirname(configPath),
				path.resolve(this.pkgPath, name, packageContent.browser)
			);

			rollupConfig.push('{\n\t\t' + [
				input,
				'"output": ' + JSON.stringify(output, null, '\t').split('\n').join('\n\t\t'),
				'"external": ' + JSON.stringify(keys(pkg.deps)),
				onwarn,
				'"plugins": [\n\t\t\t' + plugins.join(',\n\t\t\t') + '\n\t\t]'
			].join(',\n\t\t') + '\n\t}');
		}

		writeFile(configPath,
			autogenerated +
			'var mrepo = require("mrepo");\n\n' +
			'module.exports = [\n\t' +
			rollupConfig.join(', ') +
			'\n];\n'
		);
	}

	addPackageDeps() {
		for(let name of keys(this.packages)) {
			const fullName = this.getFullName(name);
			const pkg = this.packageTbl[fullName];
			if(!pkg) continue;

			const json = pkg.json;

			let tsconfig: { [key: string]: any } | undefined;
			let refList: { path: string }[] | undefined;

			if(this.tsconfigContent) {
				tsconfig = assign({}, this.tsconfigContent, -1);
				refList = tsconfig.references || (tsconfig.references = []);
			}

			for(let dep of keys(pkg.deps)) {
				const depTbl = json.dependencies || (json.dependencies = {});
				depTbl[dep] = pkg.deps[dep];

				if(refList) {
					refList.push({ path: path.relative(
						path.dirname('/' + fullName + '/' + this.referencesOut),
						'/' + dep + '/' + this.shortRefsOut
					) });
				}
			}

			this.writePackage(name, json);

			if(tsconfig && this.referencesOut) {
				writeFile(
					path.resolve(this.pkgPath, name, this.referencesOut),
					JSON.stringify(tsconfig, null, '\t') + '\n'
				);
			}
		}
	}

	packageTbl: { [name: string]: { json: PackageJson, deps: { [dep: string]: string } } } = {};

	packageContent?: PackageJson;
	tsconfigContent?: Object;
	shortRefsIn?: string;
	shortRefsOut?: string;

	basePath: string;
	scope?: string;
	packages: { [name: string]: Object }

	pkgPath: string;
	referencesIn?: string;
	referencesOut?: string;

}
